#include "stm32f10x.h"                  // Device header
#include "MPU6050_Reg.h"
#include "math.h"
#include "Delay.h"
#include "MPU6050.h"
#include "OLED.h"
#include "Serial.h"
#include "control.h"

float ax,ay,az,gx,gy,gz;
float yaw, pitch, roll;//yaw偏航角 pitch俯仰角 roll翻滚角

#define MPU6050_ADDRESS		0xD0		//MPU6050的I2C从机地址

///*引用主函数的参数*/
//extern float ax,ay,az,gx,gy,gz;
//extern float p,pa,GY,GZ;
#define pi 3.1415927
#define lb 0.95238

int16_t gx_offset_raw = 0, gy_offset_raw = 0, gz_offset_raw = 0;


/** 函    数：MPU6050等待事件
  * 参    数：同I2C_CheckEvent
  * 返 回 值：无
  */
void MPU6050_WaitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT){
	uint32_t Timeout;
	Timeout = 10000;									//给定超时计数时间
	while (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS)	//循环等待指定事件
	{
		Timeout --;										//等待时，计数值自减
		if (Timeout == 0)								//自减到0后，等待超时
		{
			/*超时的错误处理代码，可以添加到此处*/
			break;										//跳出等待，不等了
		}
	}
}

/** 函    数：MPU6050写寄存器
  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述
  * 参    数：Data 要写入寄存器的数据，范围：0x00~0xFF
  * 返 回 值：无
  */
void MPU6050_WriteReg(uint8_t RegAddress, uint8_t Data){
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成起始条件
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	//硬件I2C发送从机地址，方向为发送
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	//等待EV6
	
	I2C_SendData(I2C2, RegAddress);											//硬件I2C发送寄存器地址
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);			//等待EV8
	
	I2C_SendData(I2C2, Data);												//硬件I2C发送数据
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				//等待EV8_2
	
	I2C_GenerateSTOP(I2C2, ENABLE);											//硬件I2C生成终止条件
}

/** 函    数：MPU6050读寄存器
  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述
  * 返 回 值：读取寄存器的数据，范围：0x00~0xFF
  */
uint8_t MPU6050_ReadReg(uint8_t RegAddress){
	uint8_t Data;
	
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成起始条件
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	//硬件I2C发送从机地址，方向为发送
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	//等待EV6
	
	I2C_SendData(I2C2, RegAddress);											//硬件I2C发送寄存器地址
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				//等待EV8_2
	
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成重复起始条件
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Receiver);		//硬件I2C发送从机地址，方向为接收
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);		//等待EV6
	
	I2C_AcknowledgeConfig(I2C2, DISABLE);									//在接收最后一个字节之前提前将应答失能
	I2C_GenerateSTOP(I2C2, ENABLE);											//在接收最后一个字节之前提前申请停止条件
	
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);				//等待EV7
	Data = I2C_ReceiveData(I2C2);											//接收数据寄存器
	
	I2C_AcknowledgeConfig(I2C2, ENABLE);									//将应答恢复为使能，为了不影响后续可能产生的读取多字节操作
	
	return Data;
}

/** 函    数：MPU6050初始化
  * 参    数：无
  * 返 回 值：无
  */
void MPU6050_Init(void){//(PB10,PB11)
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);		//开启I2C2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		//开启GPIOB的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);					//将PB10和PB11引脚初始化为复用开漏输出
	
	/*I2C初始化*/
	I2C_InitTypeDef I2C_InitStructure;						//定义结构体变量
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;				//模式，选择为I2C模式
	I2C_InitStructure.I2C_ClockSpeed = 400000;				//时钟速度，选择为400KHz
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;		//时钟占空比，选择Tlow/Thigh = 2
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;				//应答，选择使能
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	//应答地址，选择7位，从机模式下才有效
	I2C_InitStructure.I2C_OwnAddress1 = 0x00;				//自身地址，从机模式下才有效
	I2C_Init(I2C2, &I2C_InitStructure);						//将结构体变量交给I2C_Init，配置I2C2
	
	/*I2C使能*/
	I2C_Cmd(I2C2, ENABLE);									//使能I2C2，开始运行
	
	/*MPU6050寄存器初始化，需要对照MPU6050手册的寄存器描述配置，此处仅配置了部分重要的寄存器*/
	MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x80);
	Delay_ms(100);
	MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x00);				//电源管理寄存器1，取消睡眠模式，选择时钟源为X轴陀螺仪
	MPU6050_WriteReg(MPU6050_PWR_MGMT_2, 0x00);				//电源管理寄存器2，保持默认值0，所有轴均不待机
	MPU6050_WriteReg(MPU6050_CONFIG, 0x06);					//配置寄存器，配置DLPF
	MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x04);				//采样率分频寄存器，配置采样率 200hZ		
	MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);			//陀螺仪配置寄存器，选择量程为±2000°/s
	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x00);			//加速度计配置寄存器，选择满量程为±2g
}


/** 函    数：MPU6050欧拉角计算
  * 参    数：无
  * 返 回 值：
  */
void MPU6050_CalEularAngle(void)
{

	MPU6050_UpDate();		//更新传感器值
	//通过陀螺仪测量结果计算欧拉角 法1  采样频率200hz
	float yaw_g = yaw + gx * 0.005*90/4 + 0.00685;
	float pitch_g = pitch + gy *0.005*90/4;
	float roll_g = roll + gz * 0.005*90/4;

	//加速度计计算欧拉角
	float pitch_a = atan2(az,ax)/3.1415927 * 180.0f;
	float roll_a = atan2(ay,ax)/3.1415927 * 180.0f;
	//互补滤波
	yaw = yaw_g;
	pitch =0.95238*pitch_g + (1-0.95238) * pitch_a;
	roll =0.95238 *roll_g + (1-0.95238) *  roll_a;
	
}

/** 函    数：MPU6050获取ID号
  * 参    数：无
  * 返 回 值：MPU6050的ID号
  */


uint8_t MPU6050_GetID(void){
	return MPU6050_ReadReg(MPU6050_WHO_AM_I);		//返回WHO_AM_I寄存器的值
}

 /** 函    数：MPU6050获取数据
  * 参    数：ax ay az 加速度计X、Y、Z轴的数据，使用输出参数的形式返回，范围:+-2g
  * 参    数：gx gy gz 陀螺仪X、Y、Z轴的数据，使用输出参数的形式返回，范围：±2000°/s
  * 返 回 值：无
  */
void MPU6050_UpDate(void){
	uint8_t DataH, DataL;								//定义数据高8位和低8位的变量
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);		//读取加速度计X轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);		//读取加速度计X轴的低8位数据
	int16_t ax_raw = (int16_t)((DataH << 8) | DataL);						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);		//读取加速度计Y轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);		//读取加速度计Y轴的低8位数据
	int16_t ay_raw = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);		//读取加速度计Z轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);		//读取加速度计Z轴的低8位数据
	int16_t az_raw = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);		//读取陀螺仪X轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);		//读取陀螺仪X轴的低8位数据
	int16_t gx_raw = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);		//读取陀螺仪Y轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);		//读取陀螺仪Y轴的低8位数据
	int16_t gy_raw = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);		//读取陀螺仪Z轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);		//读取陀螺仪Z轴的低8位数据
	int16_t gz_raw = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	
	ax = ax_raw * 6.1035e-5f;
	ay = ay_raw * 6.1035e-5f;
	az = az_raw * 6.1035e-5f;
	
	gx = (gx_raw * 6.1035e-2f)+3.235;		//后面加的是误差值
	gy = (gy_raw * 6.1035e-2f)+0.38;
	gz = (gz_raw * 6.1035e-2f)-0.20;
}


float MPU6050_GetAx(void)
{
	return ax;
}
float MPU6050_GetAy(void)
{
	return ay;
}	
float MPU6050_GetAz(void)
{
	return az;
}	

float MPU6050_GetGx(void)
{
	return gx;
}	
float MPU6050_GetGy(void)
{
	return gy;
}	
float MPU6050_GetGz(void)
	{
	return gz;
}



void MPU6050_Angle_Init(void){//获得初始角度值
//	MPU6050_GetData(&ax, &ay, &az, &gx, &gy, &gz);//读取MPU6050的数值(频率:1000HZ,加速度量程:±2g,角速度量程±2000°/s
//	p=atan2((float)ax,(float)az)/pi*180.f;//通过加速度值解算出初始角度
}
void MPU6050_Angle(void){//更新角度值，读取MPU6050的数值
//	GY=(float)gy/32768.f*2000.f;//将GY的数值转换成角速度值
//	GZ=(float)gz/32768.f*2000.f;//将GZ的数值转换成角速度值
//	p-=GY*0.01;//在原角度的基础上加减角度差值（0.01是时间间隔(10ms)）
//	pa=atan2((float)ax,(float)az)/pi*180.f;//通过加速度值解算出角度
//	p=lb*p+(1-lb)*pa;//用滤波值(lb)将两者融合
}

float MPU6050_GetYaw(void)
{
	return yaw;
	
}

float MPU6050_GetPitch(void)
{
	return pitch;
}

float MPU6050_GetRoll(void)
{
	return roll;
}


